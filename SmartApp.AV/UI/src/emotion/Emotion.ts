/**
 * This interface represent the concept of emotional state of ELF.
 * It is based on the Circumplex Model of Affect, providing Arousal and Valence values.
 */
export interface IEmotion {
	/**
	 * Returns the emotion color code
	 */
	getColor(): string

	/**
	 * Returns Arousal value
	 */
	getArousal(): number;

	/**
	 * Returns Valence value
	 */
	getValence(): number;

	/**
	 * Returns the label of the emotion (i.e. sad, happy, ...)
	 */
	getLabel(): string;
}

export enum EMOTION {
	ANGER = "angry", DISGUST = "disgust", FEAR = "fear", HAPPINESS = "happy", SADNESS = "sad", SUPRISE = "surprise"
}

/**
 * This is an implementation of IEmotion based on trigonometry.
 */
export class Emotion implements IEmotion {
	private color: string;

	constructor(private valence: number, private arousal: number) {
		this.color = this.getColorFromCoord(valence, arousal);
	}

	/**
	 * Returns the hex color code out of valence and arousal values.
	 * This function map the HSL color to the Russell model, based on https://www.google.it/amp/s/cm4group.wordpress.com/2013/11/20/colors-and-emotions-by-p-zarc/amp/
	 * valence and arousal are between [0,1]
	 * The color is in HSL format: 
	 * 		hue = angle generated by valence and arousal (angle = 0 means yellow),
	 * 		saturation = the max possible saturation in order to have full color
	 * 		lightness = between 50% and 100%, in order to have from full color to white
	 * 
	 * @param valence The value of valence
	 * @param arousal the value of arousal
	 */
	private getColorFromCoord(valence: number, arousal: number): string {
		var hue = Math.atan2(-arousal, valence) * 180.0 / Math.PI;
		var dist = Math.sqrt(Math.pow(valence, 2) + Math.pow(arousal, 2));
		return this.hslToHex(hue + 60, 100, 100 - dist * 50);
	}

	public getArousal(): number {
		return this.arousal;
	}

	public getValence(): number {
		return this.valence;
	}

	public getColor(): string {
		return this.color;
	}

	public getLabel(): string {
		let intensity = this.getIntensity();
		if (intensity < 0.2) {
			return "normal";
		}

		let angle = this.getAngle();

		if (angle < 0) {
			angle = 360 + angle;
		}

		// Emotions mapped into 6 basic ones
		if (angle < 60.0) return EMOTION.HAPPINESS;
		else if (angle < 120.0) return EMOTION.ANGER;
		else if (angle < 180.0) return EMOTION.DISGUST;
		else if (angle < 240.0) return EMOTION.SADNESS;
		else if (angle < 300.0) return EMOTION.DISGUST;
		else return EMOTION.SUPRISE;
	}

	private getAngle(): number {
		return Math.atan2(this.getArousal(), this.getValence()) * 180.0 / Math.PI
	}

	private getIntensity(): number {
		return Math.sqrt(Math.pow(this.getValence(), 2) + Math.pow(this.getArousal(), 2));
	}

	private hslToHex(h: number, s: number, l: number): string {
		h /= 360;
		s /= 100;
		l /= 100;
		let r, g, b;
		if (s === 0) {
			r = g = b = l; // achromatic
		} else {
			const hue2rgb = (p, q, t) => {
				if (t < 0) t += 1;
				if (t > 1) t -= 1;
				if (t < 1 / 6) return p + (q - p) * 6 * t;
				if (t < 1 / 2) return q;
				if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
				return p;
			};
			const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
			const p = 2 * l - q;
			r = hue2rgb(p, q, h + 1 / 3);
			g = hue2rgb(p, q, h);
			b = hue2rgb(p, q, h - 1 / 3);
		}
		const toHex = x => {
			const hex = Math.round(x * 255).toString(16);
			return hex.length === 1 ? '0' + hex : hex;
		};
		return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
	}
}

/**
 * Returns a neutral emotion.
 */
export function getNeutral(): IEmotion {
	return new Emotion(0, 0);
}